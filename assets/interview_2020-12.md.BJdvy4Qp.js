import{_ as a,c as o,o as r,aa as t}from"./chunks/framework.qnqjiyko.js";const b=JSON.parse('{"title":"2020 年 12 月面试题","description":"","frontmatter":{},"headers":[],"relativePath":"interview/2020-12.md","filePath":"interview/2020-12.md"}'),i={name:"interview/2020-12.md"};function d(n,e,l,c,p,s){return r(),o("div",null,e[0]||(e[0]=[t('<h1 id="_2020-年-12-月面试题" tabindex="-1">2020 年 12 月面试题 <a class="header-anchor" href="#_2020-年-12-月面试题" aria-label="Permalink to &quot;2020 年 12 月面试题&quot;">​</a></h1><h2 id="原型与原型链的关系" tabindex="-1">原型与原型链的关系 <a class="header-anchor" href="#原型与原型链的关系" aria-label="Permalink to &quot;原型与原型链的关系&quot;">​</a></h2><h2 id="app-bridge-通信" tabindex="-1">APP bridge 通信 <a class="header-anchor" href="#app-bridge-通信" aria-label="Permalink to &quot;APP bridge 通信&quot;">​</a></h2><p>bridge 中原生应用与 <code>JavaScript</code> bridge 通信原理是什么？</p><blockquote><p>实际上，我不太懂这个题目的出题人是什么居心。</p></blockquote><p>于是回答：通过共享浏览器 window 作用域，H5 给 window 放数据，原生调用浏览器 window 来获取。</p><p>搜了下大致的描述：</p><ol><li><p>H5 中的 <code>JavaScript</code> 发起请求，在 android 的 WebViewClient.shouldOverrideUrlLoading 方法中拦截 URL 请求，判断是否为接口调用 <a href="https://github.com/DavidAnson/markdownlint/blob/v0.38.0/doc/md013.md" target="_blank" rel="noreferrer">https://github.com/DavidAnson/markdownlint/blob/v0.38.0/doc/md013.md</a></p></li><li><p>android 通过 webView.addJavascriptInterface 方法向 windows 对象中注入原生代码，然后 H5 在 <code>JavaScript</code> 中调用相应的方法</p></li><li><p>选择 prompt,console.log,alert 等方法作为通信的接口</p></li></ol>',8)]))}const h=a(i,[["render",d]]);export{b as __pageData,h as default};
