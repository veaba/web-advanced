import{_ as t,c as a,o as l,aa as i}from"./chunks/framework.qnqjiyko.js";const v=JSON.parse('{"title":"EventLoop","description":"","frontmatter":{},"headers":[],"relativePath":"javascript/eventloop.md","filePath":"javascript/eventloop.md"}'),o={name:"javascript/eventloop.md"};function r(n,e,s,c,p,d){return l(),a("div",null,e[0]||(e[0]=[i('<h1 id="eventloop" tabindex="-1">EventLoop <a class="header-anchor" href="#eventloop" aria-label="Permalink to &quot;EventLoop&quot;">​</a></h1><h2 id="javascript-事件" tabindex="-1">JavaScript 事件 <a class="header-anchor" href="#javascript-事件" aria-label="Permalink to &quot;JavaScript 事件&quot;">​</a></h2><p>分为两种事件类型：</p><ul><li><p>宏任务 (macro-task)/Task 中的异步任务：</p><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate (Node)</li><li>requestAnimationFrame(browser)</li><li>I/O</li><li>UI rendering(browser)</li></ul></li><li><p>微任务 (micro-task)/jobs 中的异步任务：</p><ul><li>process.nextTick(node,limit=1000)</li><li>Promise</li><li>Object.observe</li><li>MutationObserve</li></ul></li></ul><p>事件的执行顺序：先 <code>宏任务</code> ——&gt; <code>微任务</code>。</p><p>任务中有 <code>同步任务</code> 和 <code>异步任务</code>：</p><ul><li>——&gt; 同步的进入主线程</li><li>——&gt; 异步进入 event table 并注册函数</li><li>——&gt; 异步完成后</li><li>——&gt; 将回调放入 event queue (宏任务和微任务是不同的 event queue)，此时不执行异步快里的代码</li><li>——&gt; 同步任务完成后，从 event queue 读取事件放入主线程</li><li>——&gt; 回调函数可能包含不同的任务，因此循环执行上述</li></ul><h2 id="node" tabindex="-1">Node <a class="header-anchor" href="#node" aria-label="Permalink to &quot;Node&quot;">​</a></h2><ul><li>略</li></ul><h2 id="reference" tabindex="-1">reference <a class="header-anchor" href="#reference" aria-label="Permalink to &quot;reference&quot;">​</a></h2><ul><li><a href="https://segmentfault.com/a/1190000016278115" target="_blank" rel="noreferrer">带你彻底弄懂 Event Loop</a></li></ul>',11)]))}const h=t(o,[["render",r]]);export{v as __pageData,h as default};
